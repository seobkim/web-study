# 4장 : 인증 백엔드 통합

## Rest API 인증 기법

### **Basic 인증**

최초 로그인 후 HTTP 요청 헤더의 Authorization: 부분에 아이디와 비밀번호를 세미콜론으로 이어붙인 후 Base64로 인코딩 한다.

```java
Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

한계점

- 단순 인코딩만 하였음으로 HTTPS 와 사용하여야 한다.
- 로그아웃 사용 불가
- DB 과부화
    
    

❗왜 로그아웃 Basic 인증에서는 로그아웃 사용이 불가할까?

### **토큰 기반 인증**

토큰은 사용자를 구별할 수 있는 문자열이다.

```java
Authorization: Bearer hY_9.B5f-4.1BfE
```

아이디와 패스워드를 매번 보낼 필요가 없어 안전하다.

디바이스마다 다른 토큰을 생성해 주고 유효시간을 다르게 정하거나 임의로 로그아웃을 할 수 있다.

❗서버에서 토큰을 생성해서 클라이언트에 내려주는 방식이므로 Basic 인증과는 다르게 로그아웃 등이 가능

한계점

- Basic 인증과 기능적으로는 비슷하기 때문에 스케일 이슈가 있음

### JSON 웹 토큰 (JWT)

서버에서 전자 서명된 토큰을 이용하면 스케일 이슈를 해결할 수 있다.

```java
{header}.{payload}.{signature}
```

header

```
{
  "typ": "JWT",
  "alg": "HS512"
}
```

header에는 보통 토큰의 타입이나, 서명 생성에 어떤 알고리즘이 사용되었는지 저장합니다.

지금같은 경우에는 현재 토큰의 타입이 `JWT`이고, 앞서 이야기했던 개인키로 `HS512` 알고리즘이 적용되어 암호화가 되어있다고 확인할 수 있다.

payload

```
{
  "sub": "1",
  "iss": "ori",
  "exp": 1636989718,
  "iat": 1636987918
}
```

주로 사용자의 권한이 담겨있다.

1. `iss` (Issuer) : 토큰 발급자
2. `sub` (Subject) : 토큰 제목 - 토큰에서 사용자에 대한 식별값이 됨
3. `aud` (Audience) : 토큰 대상자
4. `exp` (Expiration Time) : 토큰 만료 시간
5. `nbf` (Not Before) : 토큰 활성 날짜 (이 날짜 이전의 토큰은 활성화 되지 않음을 보장)
6. `iat` (Issued At) : 토큰 발급 시간
7. `jti` (JWT Id) : JWT 토큰 식별자 (issuer가 여러명일 때 이를 구분하기 위한 값)

**Signature**

1. 사용자의 정보를 바탕으로 header, payload 작성
2. Header, Payload secret 키로 전자 서명 → 결과 X
3. Base64 인코딩

인증 확인

1. 개인키로 Signature 복호화
2. header가 JWT의 header 값과 일치하는지 확인

❗왜 전자서명일까?

전자서명이란 어떤 데이터가 그 사람 것이 맞는지를 보장해 주는 것이다. 이때 공개키 암호화 기술이 사용된다.

어떤 사람 A가 자신의 비밀키를 사용하여 원본 데이터의 해시값을 암호화(서명) 한다. 그 후에 믿을 수 있는 기관 B에 A의 공개키를 배포한다. 그러면 믿을 수 있는 기관 B는 자신의 비밀키로 A의 공개키를 서명하고, A의 주체 정보와 B의 공개키 등을 담아 인증서를 만들어 배포한다. 그리고 A는 이 인증서와 함께 원본 데이터와 원본 데이터의 해시값을 서명한 데이터를 합쳐 배포한다.(이를 “코드사인”이라고 한다.)

기관 B를 믿을 수 있는 사용자 C는 코드사인된 데이터를 받아 인증서 안에 들어있는 B의 공개키를 이용하여 A의 공개키를 얻어낸다. 이 A의 공개키로 서명된 데이터를 복호화하여 얻은 해시값과 원본 데이터를 해싱하여 얻은 해시값을 비교하여 일치한다면 원본데이터가 손상되지 않았다는 것을 의미하는 것이다.

![스크린샷 2022-06-13 오후 8.09.03.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9290db59-8307-419f-bc60-a20a96db8a19/스크린샷_2022-06-13_오후_8.09.03.png)

❗어떤식으로 인증을 하고 확인 하는지

❗스케일 이슈 해결

기존엔 클라이언트의 상태를 어디선가 들고있어야 한다는 문제점을 해결하지 못했다.

→ 

- **JSON Web Token (JWT)**은 웹표준 ([RFC 7519](https://tools.ietf.org/html/rfc7519)) 으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인 (self-contained) 방식으로 정보를 안전성 있게 전달한다.
    - 자가 수용적이라는 의미는 JWT 안에 인증에 필요한 모든 정보를 자체적으로 지니고 있다는 의미이다.
    
    ** 즉 여러 서버를 사용한다면 토큰 정보를 들고 있어야 하지만, JWT는 자체적으로 정보를 가지고 있어서 좋음
    

❗왜 굳이 전자서명을 사용하는지

- 인증에 필요한 정보가 토큰에 들어있어서 별도의 저장소가 필요 없다.
    - 하지만 보안성을 높이기위해 `Refresh Token`을 사용하는경우 별도의 저장소에 저장하면서 사용하는 경우에는 해당하지 않는다.
- Cookie와 Session 사용시 문제점이였던 stateful 특성을 JWT 사용시 stateless하게 가져갈 수 있다. 즉 서버는 클라이언트의 상태를 가질 필요가 없다.

### JWT 요약

- 클라이언트의 상태를 들고있을 필요 없이 토큰만으로 인증처리가 가능하다. 즉 `stateless`하다.
- MSA에서 중앙화된 인증방식에 비해 유리하다.
- 그런데 보안문제로 Refresh Token을 도입하면 결국 이를 저장하기위한 별도의 저장소가 필요한건 마찬가지이다. 즉 stateless 하지 않다.
- 하지만 세션은 로그인할때마다 저장소에 접근하지만JWT는 토큰이 만료되었을때만 저장소에 접근하기 때문에 접근하는 횟수 자체는 훨씬 적다.
- access token을 사용하는 기간동안은 stateless하지만, 만료되었을 때는 stateless가 깨지게된다.
- MSA 환경에서 유용하다.

## 스프링 시큐리티 통합

스프링 시큐리티를 이용해 코드를 한 번만 짜고, 이 코드가 모든 API를 수행하기 바로 전엔 실행되도록 설정 및 구현 할 수 있다.

인증과 인가를 담당하는 프레임워크를 말한다.

### 서블릿 필터

디스패처 서블릿이 실행되기 전에 항상 실행된다. 

개발자는 서블릿 필터를 구현하고 서블릿 컨테이너가 실행하도록 설정해 주기만 하면 된다.

원치않는 HTTP 요청을 걸러낼 수 있다.

![스크린샷 2022-06-13 오후 8.44.40.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4504dab2-ba3c-4f58-974b-e034a6d29042/스크린샷_2022-06-13_오후_8.44.40.png)

[https://www.bottlehs.com/springboot/스프링-부트-spring-security를-활용한-인증-및-권한부여/](https://www.bottlehs.com/springboot/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-spring-security%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9D%B8%EC%A6%9D-%EB%B0%8F-%EA%B6%8C%ED%95%9C%EB%B6%80%EC%97%AC/)

추가 참고할만한 블로그

[https://velog.io/@znftm97/JWT-Session-Cookie-비교-sphsi9yh](https://velog.io/@znftm97/JWT-Session-Cookie-%EB%B9%84%EA%B5%90-sphsi9yh)
