# 4장 백앤드 통합
## 4.1 REST API 인증 기법
	⁃ Basic 인증
	⁃ Bearer 인증
	⁃ Json 웹 토큰

### 4.1.1 Basic 인증
	가장 간단한 방법으로서 HTTP 요청에 아이디와 비밀번호를 같이 보내는것이다
	이런 방법을 Basic 인증이라고 한다

Basic 인증에서는 최초 로그인 한 후 HTTP 요청 헤더의 Authorization : 부분에 'Basic <ID>:<Password>' 처럼 아이디와 비밀번호를 콜론으로 이어붙인 후 Base64로 인코딩한 문자열을 함께 보낸다.

이 인증은 아이디와 비밀번호를 노출한다 따라서 Basic 인증은 HTTP와 사용하기엔 취약하다.
중간에 누군가 HTTP 요청을 가로채 디코딩 가능하기 때문에 반드시 HTTPS와 사용해야 한다.

또 이 인증방법을 이용하면 사용자를 로그아웃시킬 수 없다. 모든 요청이 일종의 로그인 요청이기 때문이다.

마지막으로 인증서버와 인증 DB 에 과부하가 걸릴 확률이 높다

### 4.1.2 토큰 기반 인증
	토큰(Token)은 사용자를 구별할 수 있는 문자열이다.
	토큰은 최초 로그인 시 서버가 생성해주며, 서버가 자기만의 노하우로 토큰을 만들어 반환하면
	클라이언트는 이후 요청에 아이디와 비밀번호 대신 토큰을 계속 넘겨 자신이 인증된 사용자임을 알리는 것이다

토큰을 기반으로 하는 요청은 헤더에 Authorization:Bearer <Token>을 명시한다.
서버는 토큰을 받고 어떤 형태로든 인증을 해야한다.

토큰 기반인증 방법은 아이디와 비밀번호를 매번 네트워크를 통해 전송해야 할 필요가 없으므로 보안 측면에서 좀 더 안전하다. 또 서버가 토큰을 마음대로 생성할 수 있으므로 사용자의 인가 정보 또는 유효 시간을 정해 관리할 수 있다. 디바이스마다 다른 토큰을 생성해 주고 디바이스마다 유효 시간을 다르게 정하거나 임의로 로그아웃할 수 도 있다.

하지만 이 디자인은 Basic 인증에서 마주한 스케일 문제를 해결하지 못한다
세션 기반 인증에 대해 알고 있다면 토큰은 이름만 바뀐 세션이라는 생각이 들 수도 있다.
실제로 기능적으로 둘은 거의 같은 기능을 하고 제약도 비슷하다.
결국 토큰 이용만으로는 스케일 문제를 해결할 수 없다는 뜻이다.

### 4.1.3 JWT
	서버에서 전자 서명된 토큰을 이용하면 인증에 따른 스케일 문제를 해결할 수 있다.
	전자 서명(Digital Signature) 된 토큰을 이용해 스케일 문제를 해결한다,
	그리고 이렇게 전자 서명된 토큰 중 하나가 바로 JSON 웹 토큰(JSON Web Token/JWT)이다.

	JWT 토큰은 {header}.{payload}.{signature}로 구성되어 있다.

- Header
￼<img src="https://user-images.githubusercontent.com/61955818/173989326-55295921-0af1-42f4-8d25-628c1389a7b6.png">

typ : Type을 줄인 말로 토큰의 타입을 의미한다.
alg : Algorithm을 줄인 말로 토큰의 서명을 발행하는 데 사용된 해시 알고리즘의 종류를 의미한다.

- Payload
￼ <img src= "https://user-images.githubusercontent.com/61955818/173989426-795b33ab-cefe-4859-8d2b-ea6da692a7f8.png">

sub : Subject를 줄인 말로 토큰의 주인을 의미한다. 우리의 애플리케이션에서는 사용자의 이메일로 토큰의 주인을 판별한다. sub는 ID처럼 유일한 식별자 (Unique Identifier)여야 한다.
iss : Issuer를 줄인 말로 토큰을 발행한 주체를 의미한다. 예를 들어 우리 애플리케이션이 이 토큰을 발행했다면 demo app, 페이스북이 발행했다면 facebook이 된다.
iat : issued at 을 줄인 말로 토큰이 발행된 날짜와 시간을 의미한다.
exp : expiration을 줄인 말로 토큰이 만료되는 시간을 의미한다.

- Signature
토큰을 발행한 주체 Issuer가 발행한 서명으로 토큰의 유효성 검사에 사용된다.

JWT도 토큰 기반 인증이므로 서버가 생성한다. 다른점은 서버가 헤더와 페이로드를 생성한 후 전자 서명을 한다는 점이다.

JWT에서 전자 서명이란 {헤더}.{페이로드} 와 시크릿키를 이용해 해시 함수에 돌린 암호화한 결과 값이다. 시크릿키란 나만 알고 있는 문자열,비밀번호 같은 것이다 너무 간단하지만 않으면 아무것이나 상관없다.

최초 로그인 시 서버는 사용자의 아이디와 비밀번호를 서버에 저장된 아이디와 비밀번호에 비교해 인증한다. 만약 인증된 사용자인 경우 사용자의 정보를 이용해 {헤더}.{페이로드} 부분을 작성하고 자신의 시크릿키로 {헤더}.{페이로드} 부분을 전자 서명한다. 전자 서명의 결과로 나온 값을 {헤더}.{페이로드}.{서명}으로 이어붙이고 Base64로 인코딩한 후 반환한다.

이후에 누군가 이 토큰으로 리소스 접근을 요청하면 서버는 일단 이 토큰을 Base64로 디코딩한다.
디코딩해서 얻은 JSON을 {헤더}.{페이로드}와 {서명} 부분으로 나눈다.
서버는 {헤더}.{페이로드}와 자신이 갖고 있는 Secret으로 전자 서명을 만든 후 방금 만든 전자 서명을 HTTP 요청이 갖고 온 {서명} 부분과 비교해 이 토큰의 유효성을 검사한다.
서버가 방금 시크릿키를 이용해 만든 저자 서명과 HTTP 요청의 {서명} 부분이 일치하면 토큰이 위조되지 않았다는 뜻이다. 누군가 헤더나 페이로드 부분을 변경했다면 서명이 일치하지 않기 때문이다. 따라서 인증 서버에 토큰의 유효성에 대해 물어볼 필요가 없다
이는 인증 서버에 부하를 일으키지 않는다는 뜻이고 더 이상 인증 서버가 단일 장애점이 아니라는 뜻이기도 하다

누군가 토큰을 탈취하면 당연히 해당 계정의 리소스에 접근할 수 있다. 그렇기에 반드시 HTTPS를 통해 통신해야한다.
￼<img src="https://user-images.githubusercontent.com/61955818/173989664-62f7c26c-e772-4309-b00b-7ae8eee13866.png">
### 4.3.2 스프링 시큐리티와 서블릿 필터
API를 호출할때 마다 사용자를 인증해 주는 부분을 스프링 시큐리티의 도움을 받아 구현한다
토큰인증을 위해 컨트롤러 메서드의 첫 부분마다 인증 코드를 작성해야 한다는 문제점이 있었다 이 문제점을 해결하기 위해 서블릿 필터를 사용한다. 참고로 스프링 시큐리티는 인증과 인가를 위한 다양한 기능을 제공하지만 여기서는 구현에 필요한 부분, 즉 서블릿 필터만 짚고 넘어간다

스프링 시큐리티란 아주 간단히 말하면 서블릿 필터의 집합이다.
서플릿 필터는 서블릿 실행 전에 실행되는 클래스들이다 스프링이 구현하는 기본 서블릿인 디스패처 서블릿이 실행되기 전에 항상 실행된다. 개발자는 서블릿 필터를 구현하고 서블릿 필터를 서블릿 컨테이너가 실행하도록 설정해 주기만 하면 된다.

￼<img src= "https://user-images.githubusercontent.com/61955818/173989497-6300ae13-1fef-4513-aa32-2bef02bcebaf.png">

서블릿 필터는 이름에서 유추할 수 있듯이 구현된 로직에 따라 원하지 않는 HTTP 요청을 걸러낼 수 있다. 걸러낸 HTTP는 거절되는 것이고 서블릿 필터가 전부 살아 남은 HTTP 요청은 디스패처 서블릿 넘어와 컨트롤러에서 실행된다

서블릿 필터란 HttpFilter 또는 Filter를 상속하는 클래다. 이 클래스를 상속해 doFilter 라는 메서드를 원하는 대로 오버라이딩해 준다. 
그런데 서블릿 필터는 꼭 1개일 필요는 없다. 걸러내고 싶은 모든 것을 하나의 클래스에 담으면 그 크기가 어마어마해질 것이다. 그래서 기능에 따라 다른 서블릿 필터를 작성할 수 있고 이 서블릿 필터들은 FilterChain을 이용해 연쇄적(chained)으로 순서대로 실행할 수 있다.

스프링 시큐리티 프로젝트를 추가하면 스프링 시큐리티가 FilterChainProxy라는 필터를 서블릿 필터에 끼워 넣어준다. 이 FilterChainProxy 클래스 안에서 내부적으로 필터를 실행시키는데 이 필터들이 스프링이 관리하는 스프링 Bean 필터다

스프링이 관리하는 필터라고 크게 다른 것은 없다. 단지 우리가 상속할 필터는 HttpFilter가 아닌 OncePerRequestFilter 라는 점, Web.xml 대신 WebSecurityConfigureAdapter 라는 클래스를 상속해 필터를 설정한다는 점이 다를뿐이다.

HttpSecurity는 시큐리티 설정을 위한 오브젝트
- 제공되는 빌더를 이용해 cors(교차 출처 리소스 공유 (Cross-origin resource sharing)), csrf(사이트 간 요청 위조 (Cross-site request forgery)),httpBasic,session,authorizeRequests 등 다양한 설정을 할 수 있다.
- 이 프로젝트에서는 Web.xml 이 아닌 HttpSecurity를 이용해 시큐리티 관련 설정은 한다.
	
### 4.3.6 패스워드 암호
- 패스워드 암호화는 스프링 시큐리티가 제공하는 BCryptPasswordEncoder의 사용

	
![image](https://user-images.githubusercontent.com/61955818/174045705-ca08baf1-50b8-4557-8495-c623a1e2aa3d.png)
